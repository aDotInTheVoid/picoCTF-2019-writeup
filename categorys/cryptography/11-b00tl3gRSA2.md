# b00tl3gRSA2
```
c: 1869936149079364842868711514343199866730632048925134934403014494718295768440412204585415114816078640945932273872053415374485514012744054864473371049894861152575294412432082827337481701337790353590179173939335919939880805493914189463086029606125958708376161813191429889592251081409269870483921858202046282610
n: 68930655074631658214355750702044794004602462708942820914171190783448566020028947004669477972674420580730441187867554277193099323893514265443401167991767624703377288232749335925558702172112529388666961839289542214712576315191538816006934639064639933709368487665249255939916798675632960114307898259079551543019
e: 41363441599707634200466432822059532993866076429415358012902794145912717333257219568375674202837586984121733686242386851079131133722328387278829328983814405964234037343059755907262814784734207526481476056834215399150536398954706809144437661026315908546992120446003550654528573670819776070056315216619572375289
```
As e gets biger, d gets smaller, as ed=1 mod n. 

Therfor we are vunerable to [Wiener's attack](https://en.wikipedia.org/wiki/Wiener%27s_attack). Someone has already writen [the code](https://github.com/orisano/owiener/blob/master/owiener.py) for this. After some lite mods, we get

```python
def isqrt(n):
    if n == 0:
        return 0
    x = 2 ** ((n.bit_length() + 1) // 2)
    while True:
        y = (x + n // x) // 2
        if y >= x:
            return x
        x = y

def is_perfect_square(n):
    sq_mod256 = (1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0)
    if sq_mod256[n & 0xff] == 0:
        return False
    mt = (
        (9, (1,1,0,0,1,0,0,1,0)),
        (5, (1,1,0,0,1)),
        (7, (1,1,1,0,1,0,0)),
        (13, (1,1,0,1,1,0,0,0,0,1,1,0,1)),
        (17, (1,1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1))
    )
    a = n % (9 * 5 * 7 * 13 * 17)
    if any(t[a % m] == 0 for m, t in mt):
        return False
    return isqrt(n) ** 2 == n

def rational_to_contfrac(x, y):
    while y:
        a = x // y
        yield a
        x, y = y, x - a * y

def contfrac_to_rational_iter(contfrac):
    n0, d0 = 0, 1
    n1, d1 = 1, 0
    for q in contfrac:
        n = q * n1 + n0
        d = q * d1 + d0
        yield n, d
        n0, d0 = n1, d1
        n1, d1 = n, d

def convergents_from_contfrac(contfrac):
    n_, d_ = 1, 0
    for i, (n, d) in enumerate(contfrac_to_rational_iter(contfrac)):
        if i % 2 == 0:
            yield n + n_, d + d_
        else:
            yield n, d
        n_, d_ = n, d

def attack(e, n):
    f_ = rational_to_contfrac(e, n)
    for k, dg in convergents_from_contfrac(f_):
        edg = e * dg
        phi = edg // k
        x = n - phi + 1
        if x % 2 == 0 and is_perfect_square((x // 2) ** 2 - n):
            g = edg - phi * k
            return dg // g
    return None

e = 41363441599707634200466432822059532993866076429415358012902794145912717333257219568375674202837586984121733686242386851079131133722328387278829328983814405964234037343059755907262814784734207526481476056834215399150536398954706809144437661026315908546992120446003550654528573670819776070056315216619572375289
n=68930655074631658214355750702044794004602462708942820914171190783448566020028947004669477972674420580730441187867554277193099323893514265443401167991767624703377288232749335925558702172112529388666961839289542214712576315191538816006934639064639933709368487665249255939916798675632960114307898259079551543019
d=attack(e, n)
c=1869936149079364842868711514343199866730632048925134934403014494718295768440412204585415114816078640945932273872053415374485514012744054864473371049894861152575294412432082827337481701337790353590179173939335919939880805493914189463086029606125958708376161813191429889592251081409269870483921858202046282610
m=pow(c,d,n)
print(m.to_bytes(m.bit_length(), byteorder='big'))
```
flag: `picoCTF{bad_1d3a5_4986370}`
